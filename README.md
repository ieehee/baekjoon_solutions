rhapso73

https://www.acmicpc.net/user/rhapso73

https://solved.ac/profile/rhapso73

### 1095

<ul>
    <li>이하 순서로 진행</li>
    <ol>
        <li>M 이하 소수찾기</li>
        <li>(S+F)!, S!, F!를 각각 소인수분해하여 <sub>S+F</sub>C<sub>S</sub>의 소인수분해</li>
        <li>M 이하의 수 중에  <sub>S+F</sub>C<sub>S</sub>의 소수와 지수 조합 내에서 만들 수 있는 가장 큰 수 찾기</li>
    </ol>
    <li>이후 다른 사람이 푼 코드를 보니 2. 이후 바로 <sub>S+F</sub>C<sub>S</sub>에 직접 M 이하의 수들을 하나씩 나누기도 함.</li>
    <li>팩토리얼할 수가 큰 경우 소인수분해로 접근하는 자체가 효율적인가?..</li>
</ul>

### 1058

<ul>
    <li>행렬곱으로 거리가 2인 사람까지 세기</li>
    <li>2d리스트 복사시 주소값이 같은 문제는 b= a[::1]로 해결되지 않아 값이 같이 변환되는 문제 (id(a)로 확인하면 다른 값이었지만 각 요소가 같은 주소를 가지는 것으로 추정(확인안함;)) -> copy.deepcopy로 해결</li>
    <li>a = [[0]*N]*N 방법으로 리스트 선언시에도 위와 동일한 포인터 문제 발생. a=[0][1]을 바꾸면 [i][1]이 전부 바뀜
</ul>

### 1016

<ul>
    <li>에라토스테네스의 체를 응용하여 해결</li>
    <li>A, B가 매우 큰 값이라 그대로 사용하는 것을 피하기 위해 별도의 B**0.5의 크기를 가진 checker를 만듬
    <ul>
        <li>나중에보니 크기가 어처구니없이 크진 않아서 굳이 별도의 checker를 생성하지 않아도 index처리만 잘 해주면 되는 거였다;;</li>
    </ul>
    <li>그래도 더 큰 수에서도 잘 돌아갈테니까 만족</li>
    <li>그런데 더 큰 수도 index와 실제 숫자 사이의 관계만 잘 처리해주면 돌아갈 것 같기도 하다.</li>
</ul>

### 1011

<ul>
    <li>숫자에 따른 워프횟수의 규칙성 발견</li>
    <ol>
        <li> For 16: <strong><em>1, 2, 3, 4, 3, 2, 1</em></li></strong>
        <li> For 20: <strong><em>1, 2, 3, 4, 4, 3, 2, 1</em></li></strong>
    </ol>
    <li> 위 두 케이스는 1광년만 거리가 추가되어도 워프 횟수가 추가되어야하는 경우
    <li> 워프횟수 변화의 기준점이 n^2(case 1)과 n^2+n(case 2)이라는 점을 알아내 해결 
    <ol>
        <li> <em>n^2= n(n+1) - n</em> (n까지 정수합*2 - n)
        <li> <em>n^2+n = n(n+1)</em> (n까지 정수합*2)
    </ol>
</ul>
